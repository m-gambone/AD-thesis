% Generated by ADiMat 0.6.2-5299 (cf36599d)
% Copyright 2009-2013 Johannes Willkomm, Fachgebiet Scientific Computing,
% TU Darmstadt, 64289 Darmstadt, Germany
% Copyright 2001-2008 Andre Vehreschild, Institute for Scientific Computing,
% RWTH Aachen University, 52056 Aachen, Germany.
% Visit us on the web at http://www.adimat.de
% Report bugs to johannes@johannes-willkomm.de
%
%
%                             DISCLAIMER
%
% ADiMat was prepared as part of an employment at the Institute
% for Scientific Computing, RWTH Aachen University, Germany and is
% provided AS IS. NEITHER THE AUTHOR(S), THE GOVERNMENT OF THE FEDERAL
% REPUBLIC OF GERMANY NOR ANY AGENCY THEREOF, NOR THE RWTH AACHEN UNIVERSITY,
% INCLUDING ANY OF THEIR EMPLOYEES OR OFFICERS, MAKES ANY WARRANTY,
% EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY
% FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY INFORMATION OR
% PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE
% PRIVATELY OWNED RIGHTS.
%
% Global flags were:
% FORWARDMODE -- Apply the forward mode to the files.
% NOOPEROPTIM -- Do not use optimized operators. I.e.:
%		 g_a*b*g_c -/-> mtimes3(g_a, b, g_c)
% NOLOCALCSE  -- Do not use local common subexpression elimination when
%		 canonicalizing the code.
% NOGLOBALCSE -- Prevents the application of global common subexpression
%		 elimination after canonicalizing the code.
% NOPRESCALARFOLDING -- Switch off folding of scalar constants before
%		 augmentation.
% NOPOSTSCALARFOLDING -- Switch off folding of scalar constants after
%		 augmentation.
% NOCONSTFOLDMULT0 -- Switch off folding of product with one factor
%		 being zero: b*0=0.
% FUNCMODE    -- Inputfile is a function (This flag can not be set explicitly).
% NOTMPCLEAR  -- Suppress generation of clear g_* instructions.
% UNBOUND_XML  -- Write list of unbound identifiers in XML format.
% DEPENDENCIES_XML  -- Write list of functions in XML format.
% UNBOUND_ERROR	-- Stop with error if unbound identifiers found (default).
% FUNCTION_LIST_XML	-- Write list of functions to XML file.
% VERBOSITYLEVEL=5
% AD_IVARS= S, I, E
% AD_DVARS= der_S, der_I, der_E

function [g_der_S, der_S, g_der_I, der_I, g_der_E, der_E]= g_VecFieldNoParODE(g_S, S, g_I, I, g_E, E, tau)
   %Funzione per il calcolo del campo vettoriale associato al modello SIR con vaccinazione
   
   n= length(E); 
   
   %--------Parametri e funzioni--------%
   
   mu= 1/ (75* 365); %giorni^(-1), l'inverso della speranza di vita
   p0= 0.75; %baseline
   nu= 1/ 7; %giorni^(-1), l'inverso della durata media della malattia
   beta= 20* (mu+ nu); %R0=20;
   a= n/ tau; %parametro della distribuzione di Erlang
   c= 300; %parametro di p1;
   g_tmp_E_00000= g_E(n);
   tmp_E_00000= E(n);
   g_tmp_VecFieldNoParODE_00000= c* g_tmp_E_00000;
   tmp_VecFieldNoParODE_00000= c* tmp_E_00000;
   tmp_VecFieldNoParODE_00001= 1- p0;
   [g_p1, p1]= g_min2(g_tmp_VecFieldNoParODE_00000, tmp_VecFieldNoParODE_00000, g_zeros(size(tmp_VecFieldNoParODE_00001)), tmp_VecFieldNoParODE_00001); 
   k= 1; %parametro di g;
   g_g= k* g_I;
   g= k* I; 
   
   %--------Calcolo del campo vettoriale--------%
   
   g_tmp_VecFieldNoParODE_00002= -g_p1+ g_zeros(size(1+ p0));
   tmp_VecFieldNoParODE_00002= 1- p0- p1;
   g_tmp_VecFieldNoParODE_00003= mu* g_tmp_VecFieldNoParODE_00002;
   tmp_VecFieldNoParODE_00003= mu* tmp_VecFieldNoParODE_00002;
   g_tmp_VecFieldNoParODE_00004= mu* g_S;
   tmp_VecFieldNoParODE_00004= mu* S;
   g_tmp_VecFieldNoParODE_00005= beta* g_S* I+ beta* S* g_I;
   tmp_VecFieldNoParODE_00005= beta* S* I;
   g_der_S= g_tmp_VecFieldNoParODE_00003- g_tmp_VecFieldNoParODE_00004- g_tmp_VecFieldNoParODE_00005;
   der_S= tmp_VecFieldNoParODE_00003- tmp_VecFieldNoParODE_00004- tmp_VecFieldNoParODE_00005; 
   g_tmp_VecFieldNoParODE_00006= beta* g_S;
   tmp_VecFieldNoParODE_00006= beta* S;
   g_tmp_VecFieldNoParODE_00007= g_tmp_VecFieldNoParODE_00006+ g_zeros(size(mu+ nu));
   tmp_VecFieldNoParODE_00007= tmp_VecFieldNoParODE_00006- mu- nu;
   g_der_I= g_I* tmp_VecFieldNoParODE_00007+ I* g_tmp_VecFieldNoParODE_00007;
   der_I= I* tmp_VecFieldNoParODE_00007; 
   g_tmp_VecFieldNoParODE_00008= a* g_g;
   tmp_VecFieldNoParODE_00008= a* g;
   g_tmp_E_00001= g_E(1);
   tmp_E_00001= E(1);
   g_tmp_VecFieldNoParODE_00009= a* g_tmp_E_00001;
   tmp_VecFieldNoParODE_00009= a* tmp_E_00001;
   g_der_E(1)= g_tmp_VecFieldNoParODE_00008- g_tmp_VecFieldNoParODE_00009;
   der_E(1)= tmp_VecFieldNoParODE_00008- tmp_VecFieldNoParODE_00009; 
   for i= 2: n
      tmp_VecFieldNoParODE_00010= i- 1;
      g_tmp_E_00002= g_E(tmp_VecFieldNoParODE_00010);
      tmp_E_00002= E(tmp_VecFieldNoParODE_00010);
      g_tmp_VecFieldNoParODE_00011= a* g_tmp_E_00002;
      tmp_VecFieldNoParODE_00011= a* tmp_E_00002;
      g_tmp_E_00003= g_E(i);
      tmp_E_00003= E(i);
      g_tmp_VecFieldNoParODE_00012= a* g_tmp_E_00003;
      tmp_VecFieldNoParODE_00012= a* tmp_E_00003;
      g_der_E(i)= g_tmp_VecFieldNoParODE_00011- g_tmp_VecFieldNoParODE_00012;
      der_E(i)= tmp_VecFieldNoParODE_00011- tmp_VecFieldNoParODE_00012; 
   end
   
end

